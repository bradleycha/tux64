/*----------------------------------------------------------------------------*/
/*                          Copyright (C) Tux64 2025                          */
/*                    https://github.com/bradleycha/tux64                     */
/*----------------------------------------------------------------------------*/
/* boot/src/tux64-boot/stage1/fbcon.c - Implementations for framebuffer       */
/*    console.                                                                */
/*----------------------------------------------------------------------------*/

#include "tux64-boot/tux64-boot.h"
#include "tux64-boot/stage1/fbcon.h"

#include <tux64/platform/mips/n64/memory-map.h>
#include <tux64/memory.h>
#include <tux64/endian.h>
#include <tux64/math.h>
#include "tux64-boot/stage1/video.h"
#include "tux64-boot/stage1/rsp.h"

/* generated by tux64-fontcompiler, provides TUX64_BOOT_STAGE1_FONTMAP_BIN */
#include "src/tux64-boot/stage1/fontmap.bin.c"

/*----------------------------------------------------------------------------*/
/* okay, here's how this works.  on boot, we have a compressed representation */
/* of the font map stored in ROM.  this is a 64-character bitmap stream with  */
/* 8x4 fixed-width characters.  when decompressed, this comes out to exactly  */
/* 4KiB, which fits neatly into RSP IMEM.  this allows us to render text very */
/* efficiently with a stream of RSP DMA operations.                           */
/*                                                                            */
/* when decompressing, each bit in the compressed data corresponds to a pixel */
/* for each character.  this gives us 2-color characters which are then       */
/* colored according to the initialization parameters.  once we decompress    */
/* the entire font map, we keep it around until its time to render the fbcon. */
/*                                                                            */
/* rendering text is pretty simple.  we iterate through all text labels and   */
/* issue RSP DMA copies for each character index.  because SGI is smart, they */
/* anticipated use-cases exactly like this, so allow "skip" and "count"       */
/* parameters for each DMA operation, which allows copying 2D images into     */
/* RDRAM with only a single DMA operation.  this, along with the              */
/* double-buffering of the RSP DMA queue, allows super efficient text         */
/* rendering without needing too much code, keeping the binary small.         */
/*                                                                            */
/* storing text is pretty simple.  we could make it more complicated by using */
/* only 7 bits per character, but the overhead from doing bit math makes this */
/* optimization not worth it.                                                 */
/*----------------------------------------------------------------------------*/

#define TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_HORIZONTAL 4u
#define TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_VERTICAL   8u
#define TUX64_BOOT_STAGE1_FBCON_BITS_PER_CHARACTER          8u
#define TUX64_BOOT_STAGE1_FBCON_BORDER_PIXELS               8u
#define TUX64_BOOT_STAGE1_FBCON_SEPARATION_PIXELS           1u

#define TUX64_BOOT_STAGE1_FBCON_CHARACTERS_ROWS \
   (( \
      TUX64_BOOT_STAGE1_VIDEO_FRAMEBUFFER_PIXELS_Y - \
      (2u*(TUX64_BOOT_STAGE1_FBCON_BORDER_PIXELS)) \
   ) / TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_VERTICAL)
#define TUX64_BOOT_STAGE1_FBCON_CHARACTERS_COLUMNS \
   (( \
      TUX64_BOOT_STAGE1_VIDEO_FRAMEBUFFER_PIXELS_X - \
      (2u*(TUX64_BOOT_STAGE1_FBCON_BORDER_PIXELS)) \
   ) / TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_HORIZONTAL)
#define TUX64_BOOT_STAGE1_FBCON_CHARACTERS_COLUMNS_BYTES \
   (( \
      TUX64_BOOT_STAGE1_FBCON_CHARACTERS_COLUMNS * \
      TUX64_BOOT_STAGE1_FBCON_BITS_PER_CHARACTER \
   ) / 8u)

static const Tux64UInt8
tux64_boot_stage1_fbcon_fontmap_compressed [] = {
   TUX64_BOOT_STAGE1_FONTMAP_BIN
};

/* 16-bit entries so each pixel can be written at once.  also aligned for use */
/* with RSP DMA, and marked volatile since we convert to uncached memory */
/* address and use DMA. */
static volatile Tux64BootStage1VideoPixel
tux64_boot_stage1_fbcon_fontmap [4096u / sizeof(Tux64BootStage1VideoPixel)]
__attribute__((aligned(8u)));

struct Tux64BootStage1FbconCharacterMapLine {
   /* the number of characters in the line */
   Tux64UInt8 characters_count;

   /* data for each character in the line */
   Tux64UInt8 characters_buffer
   [TUX64_BOOT_STAGE1_FBCON_CHARACTERS_COLUMNS_BYTES];
};

struct Tux64BootStage1FbconCharacterMap {
   /* the number of valid lines */
   Tux64UInt8 lines_count;

   /* data for each individual line */
   struct Tux64BootStage1FbconCharacterMapLine lines_buffer
   [TUX64_BOOT_STAGE1_FBCON_CHARACTERS_ROWS];
};

static void
tux64_boot_stage1_fbcon_character_map_initialize(
   struct Tux64BootStage1FbconCharacterMap * map
) {
   map->lines_count = TUX64_LITERAL_UINT8(0u);
   return;
}

/* this is what stores all the text in the console */
static struct Tux64BootStage1FbconCharacterMap
tux64_boot_stage1_fbcon_character_map;

static void
tux64_boot_stage1_fbcon_character_map_line_initialize(
   struct Tux64BootStage1FbconCharacterMapLine * line,
   const struct Tux64BootStage1FbconText * text
) {
   Tux64UInt32 bytes;

   bytes = (Tux64UInt32)text->length;
   bytes = bytes * TUX64_LITERAL_UINT32(TUX64_BOOT_STAGE1_FBCON_BITS_PER_CHARACTER);
   bytes = tux64_math_ceil_divide_uint32(bytes, TUX64_LITERAL_UINT32(8u));

   line->characters_count = text->capacity;
   tux64_memory_copy(
      line->characters_buffer,
      text->ptr,
      bytes
   );

   return;
}

Tux64BootStage1FbconLabel
tux64_boot_stage1_fbcon_label_push(
   const struct Tux64BootStage1FbconText * text
) {
   struct Tux64BootStage1FbconCharacterMap * map;
   Tux64UInt8 idx;

   map = &tux64_boot_stage1_fbcon_character_map;

   idx = map->lines_count;
   map->lines_count++;

   tux64_boot_stage1_fbcon_character_map_line_initialize(
      &map->lines_buffer[idx],
      text
   );

   return (Tux64BootStage1FbconLabel)idx;
}

Tux64BootStage1FbconLabelCharacter
tux64_boot_stage1_fbcon_label_character_get(
   Tux64BootStage1FbconLabel label,
   Tux64UInt8 idx
) {
   const struct Tux64BootStage1FbconCharacterMap * map;
   const struct Tux64BootStage1FbconCharacterMapLine * line;

   map   = &tux64_boot_stage1_fbcon_character_map;
   line  = &map->lines_buffer[label];

   return line->characters_buffer[idx];
}

void
tux64_boot_stage1_fbcon_label_character_set(
   Tux64BootStage1FbconLabel label,
   Tux64UInt8 idx,
   Tux64BootStage1FbconLabelCharacter character
) {
   struct Tux64BootStage1FbconCharacterMap * map;
   struct Tux64BootStage1FbconCharacterMapLine * line;

   map   = &tux64_boot_stage1_fbcon_character_map;
   line  = &map->lines_buffer[label];

   line->characters_buffer[idx] = character;
   return;
}

static void
tux64_boot_stage1_fbcon_fontmap_decompress_byte(
   Tux64BootStage1VideoPixel color_foreground,
   Tux64BootStage1VideoPixel color_background,
   Tux64UInt8 byte,
   volatile Tux64BootStage1VideoPixel * ptr_decompressed
) {
   Tux64BootStage1VideoPixel color;
   Tux64UInt8 i;

   i = TUX64_LITERAL_UINT8(8u);
   do {
      /* we're using reverse loop order for a more efficient branch */
      /* instruction, so we're going to check the least significant bit, */
      /* which corresponds to the last pixel for this byte. */
      switch (byte & TUX64_LITERAL_UINT8(1u)) {
         case 0u:
            color = color_background;
            break;

         case 1u:
            color = color_foreground;
            break;

         default:
            TUX64_UNREACHABLE;
      }

      /* discard the parsed pixel */
      byte = byte >> TUX64_LITERAL_UINT8(1u);

      /* move forward here so that we can directly use 'i' as an index */
      i--;

      ptr_decompressed[i] = color;
   } while (i != TUX64_LITERAL_UINT8(0u));
   
   return;
}

static void
tux64_boot_stage1_fbcon_fontmap_decompress(
   Tux64BootStage1VideoPixel color_foreground,
   Tux64BootStage1VideoPixel color_background
) {
   Tux64UInt32 i;
   Tux64UInt8 byte;
   volatile Tux64BootStage1VideoPixel * ptr_decompressed;

   /* done just to make it clear that we're transferring bytes, not words */
   color_foreground = tux64_endian_convert_uint16(color_foreground, TUX64_ENDIAN_FORMAT_BIG);
   color_background = tux64_endian_convert_uint16(color_background, TUX64_ENDIAN_FORMAT_BIG);

   /* convert to uncached since the data needs to be immediately ready for */
   /* RSP DMA. */
   ptr_decompressed = (volatile Tux64BootStage1VideoPixel *)tux64_platform_mips_n64_memory_map_direct_cached_to_direct_uncached(
      tux64_boot_stage1_fbcon_fontmap
   );

   i = TUX64_LITERAL_UINT32(TUX64_ARRAY_ELEMENTS(tux64_boot_stage1_fbcon_fontmap_compressed));
   do {
      i--;

      /* this one byte decompresses to 8 pixels, or 16 bytes */
      byte = tux64_boot_stage1_fbcon_fontmap_compressed[i];
      tux64_boot_stage1_fbcon_fontmap_decompress_byte(
         color_foreground,
         color_background,
         byte,
         &ptr_decompressed[i * TUX64_LITERAL_UINT32(8u)]
      );
   } while (i != TUX64_LITERAL_UINT8(0u));

   return;
}

void
tux64_boot_stage1_fbcon_initialize(
   Tux64BootStage1VideoPixel color_foreground,
   Tux64BootStage1VideoPixel color_background
) {
   tux64_boot_stage1_fbcon_fontmap_decompress(
      color_foreground,
      color_background
   );

   tux64_boot_stage1_fbcon_character_map_initialize(
      &tux64_boot_stage1_fbcon_character_map
   );
   
   return;
}

void
tux64_boot_stage1_fbcon_render(void) {
   const struct Tux64BootStage1FbconCharacterMap * map;
   Tux64UInt32 addr_base_rsp_imem;
   Tux64UInt32 addr_base_framebuffer;
   struct Tux64BootStage1RspDmaTransfer transfer;
   Tux64UInt8 idx_line;
   const struct Tux64BootStage1FbconCharacterMapLine * line;
   Tux64UInt8 idx_character;
   Tux64BootStage1FbconLabelCharacter character;
   Tux64UInt32 offset_rsp_imem;
   Tux64UInt32 addr_framebuffer_row;
   Tux64UInt32 addr_framebuffer_column;

   map = &tux64_boot_stage1_fbcon_character_map;

   addr_base_rsp_imem      = TUX64_LITERAL_UINT32(TUX64_PLATFORM_MIPS_N64_MEMORY_MAP_ADDRESS_PHYSICAL_RSP_IMEM);
   addr_base_framebuffer   = (Tux64UInt32)(Tux64UIntPtr)tux64_boot_stage1_video_render_target_get();

   /* first start off by loading the font map into RSP IMEM, split into 2 */
   /* rows because we can't store 4KiB in 11 bits */
   transfer.addr_rsp_mem   = addr_base_rsp_imem;
   transfer.addr_rdram     = (Tux64UInt32)(Tux64UIntPtr)tux64_boot_stage1_fbcon_fontmap;
   transfer.row_bytes_copy = TUX64_LITERAL_UINT16((sizeof(tux64_boot_stage1_fbcon_fontmap) / 2u) - 1u);
   transfer.row_bytes_skip = TUX64_LITERAL_UINT16(0u);
   transfer.row_count      = TUX64_LITERAL_UINT8(1u);
   tux64_boot_stage1_rsp_dma_start(&transfer, TUX64_BOOT_STAGE1_RSP_DMA_DESTINATION_RSP_MEMORY);

   /* set up copy dimensions for every character */
   transfer.row_bytes_copy = TUX64_LITERAL_UINT16((TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_HORIZONTAL * sizeof(Tux64BootStage1VideoPixel)) - 1u);
   transfer.row_bytes_skip = TUX64_LITERAL_UINT16((TUX64_BOOT_STAGE1_VIDEO_FRAMEBUFFER_PIXELS_X - TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_HORIZONTAL) * sizeof(Tux64BootStage1VideoPixel));
   transfer.row_count      = TUX64_LITERAL_UINT8(TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_VERTICAL - 1u);

   /* start the framebuffer iterator after applying padding on both sides */
   addr_framebuffer_row = addr_base_framebuffer;
   addr_framebuffer_row = addr_framebuffer_row + TUX64_LITERAL_UINT32(
      TUX64_BOOT_STAGE1_FBCON_BORDER_PIXELS *
      TUX64_BOOT_STAGE1_VIDEO_FRAMEBUFFER_PIXELS_X *
      sizeof(Tux64BootStage1VideoPixel)
   );
   addr_framebuffer_row = addr_framebuffer_row + TUX64_LITERAL_UINT32(
      TUX64_BOOT_STAGE1_FBCON_BORDER_PIXELS *
      sizeof(Tux64BootStage1VideoPixel)
   );

   /* iterate character by character and render via DMA until the entire */
   /* is drawn.  we can't use 'do while' loops here because these counts */
   /* could legitimately be zero.  also, we're forced to use forward loops */
   /* since we have to iterate over the characters and lines in order. */
   idx_line = TUX64_LITERAL_UINT8(0u);
   while (idx_line != map->lines_count) {
      line = &map->lines_buffer[idx_line];

      addr_framebuffer_column = addr_framebuffer_row;

      idx_character = TUX64_LITERAL_UINT8(0u);
      while (idx_character != line->characters_count) {

         character = line->characters_buffer[idx_character];
         if (character == TUX64_LITERAL_UINT8(0x40u)) {
            /* skip space characters as there's nothing to render */
            goto skip_rendering;
         }

         offset_rsp_imem = character * TUX64_LITERAL_UINT32(
            TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_HORIZONTAL *
            TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_VERTICAL *
            sizeof(Tux64BootStage1VideoPixel)
         );

         transfer.addr_rsp_mem   = (addr_base_rsp_imem + offset_rsp_imem);
         transfer.addr_rdram     = addr_framebuffer_column;

         tux64_boot_stage1_rsp_dma_wait_queue();
         tux64_boot_stage1_rsp_dma_start(&transfer, TUX64_BOOT_STAGE1_RSP_DMA_DESTINATION_RDRAM);

skip_rendering:
         idx_character++;
         addr_framebuffer_column += TUX64_LITERAL_UINT32(
            (
               TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_HORIZONTAL +
               TUX64_BOOT_STAGE1_FBCON_SEPARATION_PIXELS
            ) * sizeof(Tux64BootStage1VideoPixel)
         );
      }

      idx_line++;
      addr_framebuffer_row += TUX64_LITERAL_UINT32(
         (
            TUX64_BOOT_STAGE1_FBCON_CHARACTER_PIXELS_VERTICAL +
            TUX64_BOOT_STAGE1_FBCON_SEPARATION_PIXELS
         ) *
         TUX64_BOOT_STAGE1_VIDEO_FRAMEBUFFER_PIXELS_X *
         sizeof(Tux64BootStage1VideoPixel)
      );
   }

   /* wait for the final DMA to finish and return */
   tux64_boot_stage1_rsp_dma_wait_idle();
   return;
}

