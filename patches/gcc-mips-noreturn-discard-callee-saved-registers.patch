diff --git a/gcc/config/mips/mips.cc b/gcc/config/mips/mips.cc
index 24a28dcf8..093b3a90c 100644
--- a/gcc/config/mips/mips.cc
+++ b/gcc/config/mips/mips.cc
@@ -11346,6 +11346,26 @@ mips_save_reg_p (unsigned int regno)
   return false;
 }
 
+/* Return true if the current function should preserve callee-saved registers.  */
+
+static bool
+mips_reg_preserve_callee_saved (void)
+{
+  /* If we're in a noreturn and nothrow function, it's unnecessary to push
+     callee-saved registers to the stack, as they will never need to be
+     restored for the caller.  */
+  if (!TREE_THIS_VOLATILE(cfun->decl))
+    return true;
+  if (!TREE_NOTHROW(cfun->decl))
+    return true;
+  if (!optimize)
+    return true;
+  if (optimize_debug)
+    return true;
+
+  return false;
+}
+
 /* Populate the current function's mips_frame_info structure.
 
    MIPS stack frames look like:
@@ -11508,12 +11528,13 @@ mips_compute_frame_info (void)
   offset += frame->var_size;
 
   /* Find out which GPRs we need to save.  */
-  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)
-    if (mips_save_reg_p (regno))
-      {
-	frame->num_gp++;
-	frame->mask |= 1 << (regno - GP_REG_FIRST);
-      }
+  if (mips_reg_preserve_callee_saved())
+    for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)
+      if (mips_save_reg_p (regno))
+        {
+          frame->num_gp++;
+          frame->mask |= 1 << (regno - GP_REG_FIRST);
+        }
 
   /* If this function calls eh_return, we must also save and restore the
      EH data registers.  */
